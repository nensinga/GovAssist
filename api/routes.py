from fastapi import APIRouter, Request, HTTPException, UploadFile, Depends 
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from api.db.session import get_async_session
from api.services.openai_service import process_image_with_grok, process_document_with_text_model, generate_response, generate_initial_message
from api.utils.image_utils import encode_image_to_base64, convert_pdf_to_images, pil_image_to_base64
from api.utils.firebase_utils import get_current_user_uid, get_user_name_from_firebase
from api.models.api_models import (DocumentCheckResult, ConversationMessage, QuestionRequest, QuestionResponse, DocumentRequest, DocumentResponse,
                                    FunctionCallResultMessage, InitialMessageResponse, InitialMessageResponse, InitialMessageResponse, OptionsResponse)
from api.models.document_models import DocumentAnalysisResponse
from api.services.image_service import analyze_document_with_vision
import tempfile
import logging

router = APIRouter()

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


@router.get("/initial-message", response_model=InitialMessageResponse)
async def initial_message(request: Request, uid: str = None):
    """
    Generates a personalized initial greeting message.
    
    If no UID is provided, it retrieves the UID from the authentication token in the request headers.
    If no UID is found (i.e. user is not authorized), it generates a unique session ID and sets the name to 'citizen'.
    """
    try:
        # Check if the user is authenticated (based on middleware)
        if request.state.user:  # The user is authenticated
            user_id = request.state.session_id  # Use the session ID from middleware
            user_name = get_user_name_from_firebase(user_id)  # Fetch the user's name from Firebase
        else:  # The user is not authenticated
            user_id = request.state.session_id  # Session ID generated by the middleware
            user_name = "citizen"  # Set the name to "citizen" for unauthorized users

        # Generate the initial greeting message
        message = await generate_initial_message(user_name, user_id)
        return InitialMessageResponse(message=message)

    except HTTPException as e:
        logger.error(f"Error generating initial message: {e.detail}")
        raise e

    except Exception as e:
        logger.error(f"Unexpected error in initial_message: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.get("/options", response_model=OptionsResponse)
async def get_options(request: Request):
    """
    Provides predefined options for the user.
    """
    try:
        user_id = get_current_user_uid(request)  # Get user ID from request or Firebase
        logger.info(f"Fetching options for user {user_id}")

        options = ["Drivers License", "ID", "Passport", "Something Else"]
        return OptionsResponse(options=options)

    except HTTPException as e:
        logger.error(f"Error retrieving options: {e.detail}")
        raise e

    except Exception as e:
        logger.error(f"Unexpected error in get_options: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")



@router.get("/conversation-history", response_model=List[ConversationMessage])
async def conversation_history(request: Request, session: AsyncSession = Depends(get_async_session)):
    """
    Pobiera historię konwersacji dla danego użytkownika.
    """
    user = await get_current_user(request)
    user_id = user["uid"]
    session_id = request.state.session_id  # Pobranie session_id z requestu

    if not user_id or not session_id:
        raise HTTPException(status_code=400, detail="Brak wymaganych parametrów: user_id lub session_id")

    try:
        history = await get_conversation_history(session, user_id, session_id)
        return history
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Błąd podczas pobierania historii rozmów: {str(e)}")    

@router.get("/conversation-title")
async def get_conversation_title(request: Request):
    """
    Zwraca tytuł konwersacji dla danego użytkownika.
    """
    user = get_current_user(request)
    user_id = user["uid"]
    session_id = request.state.session_id  

    if not user_id or not session_id:
        raise HTTPException(status_code=400, detail="Brak wymaganych danych: user_id lub session_id")

    try:
        title = await generate_conversation_title(user_id, session_id)
        return {"user_id": user_id, "session_id": session_id, "title": title}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Błąd podczas generowania tytułu: {str(e)}")

@router.post("/validate-document")
def validate_document(request: Request, file: UploadFile):
    logger.debug(f"Received file: {file.filename}, content_type: {file.content_type}")
    
    if file.content_type not in ["image/jpeg", "image/png", "application/pdf"]:
        raise HTTPException(status_code=400, detail="Unsupported file type. Only JPEG, PNG, and PDF are allowed.")

    try:
        base64_images = []

        if file.content_type == "application/pdf":
            with tempfile.NamedTemporaryFile(delete=True, suffix=".pdf") as temp_pdf:
                temp_pdf.write(file.file.read())
                temp_pdf.flush()
                images = convert_pdf_to_images(temp_pdf.name)
                base64_images = [pil_image_to_base64(image) for image in images]
        else:
            base64_image = encode_image_to_base64(file.file)
            base64_images = [base64_image]

        aggregated_results = [process_image_with_grok(base64_image) for base64_image in base64_images]
        response = process_document_with_text_model(aggregated_results)
        return response

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error processing the document: {str(e)}")


@router.post("/generate-response", response_model=QuestionResponse)
async def ask_question(request: Request, request_data: dict, session: AsyncSession = Depends(get_async_session)):
    user = request.state.user  
    user_id = user["uid"] if user else None

    if request_data.get("start", False):  
        session_id = str(uuid.uuid4()) 
        logger.info(f"New conversation started. New Session ID: {session_id}")
    else:
        session_id = request.state.session_id  

    question = request_data.get("question")

    if not question:
        raise HTTPException(status_code=400, detail="Question is required")

    logger.debug(f"User {session_id} asked: {question}")

    try:
        response_message = await generate_response(request_data, session_id)
        logger.debug(f"Response returned: {response_message}")

        return QuestionResponse(response=response_message, session_id=session_id) 
    except Exception as e:
        logger.error(f"Error processing request: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error processing the request: {str(e)}")

@router.post("/analyze-document", response_model=DocumentAnalysisResponse)
async def analyze_document(request: Request, file: UploadFile):
    """
    Analizuje dokument i zwraca strukturyzowane dane o polach formularza
    """
    logger.debug(f"Otrzymano plik: {file.filename}, typ: {file.content_type}")
    
    if file.content_type not in ["image/jpeg", "image/png", "application/pdf"]:
        raise HTTPException(status_code=400, detail="Nieobsługiwany typ pliku. Dopuszczalne formaty: JPEG, PNG, PDF.")

    try:
        base64_images = []

        if file.content_type == "application/pdf":
            with tempfile.NamedTemporaryFile(delete=True, suffix=".pdf") as temp_pdf:
                temp_pdf.write(file.file.read())
                temp_pdf.flush()
                images = convert_pdf_to_images(temp_pdf.name)
                base64_images = [pil_image_to_base64(image) for image in images]
        else:
            base64_image = encode_image_to_base64(file.file)
            base64_images = [base64_image]

        # Analizuj wszystkie obrazy i agreguj wyniki
        results = []
        for base64_image in base64_images:
            analysis_result = analyze_document_with_vision(base64_image)
            results.append(analysis_result)
        
        # Zwróć pierwszy wynik (lub zmodyfikuj logikę agregacji według potrzeb)
        return results[0]

    except Exception as e:
        logger.error(f"Błąd analizy dokumentu: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Błąd przetwarzania dokumentu: {str(e)}")
